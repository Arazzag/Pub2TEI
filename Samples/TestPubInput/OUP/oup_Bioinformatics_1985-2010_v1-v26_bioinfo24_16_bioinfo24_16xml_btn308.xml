<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Publishing DTD v2.3 20070202//EN" "journalpublishing.dtd">
<article article-type="research-article">
  <front>
    <journal-meta>
      <journal-id journal-id-type="hwp">bioinfo</journal-id>
      <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
      <journal-title>Bioinformatics</journal-title>
      <issn pub-type="ppub">1367-4803</issn>
      <issn pub-type="epub">1460-2059</issn>
      <publisher>
        <publisher-name>Oxford University Press</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="doi">10.1093/bioinformatics/btn308</article-id>
      <article-id pub-id-type="publisher-id">btn308</article-id>
      <article-categories>
        <subj-group>
          <subject>ORIGINAL PAPERS</subject>
          <subj-group>
            <subject>SEQUENCE ANALYSIS</subject>
          </subj-group>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Memory-efficient dynamic programming backtrace and pairwise local sequence alignment</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Newberg</surname>
            <given-names>Lee A.</given-names>
          </name>
          <xref ref-type="aff" rid="AFF1">
            <sup>1</sup>
          </xref>
          <xref ref-type="aff" rid="AFF1">
            <sup>2</sup>
          </xref>
        </contrib>
      </contrib-group>
      <aff id="AFF1"><sup>1</sup>Center for Bioinformatics, Wadsworth Center, New York State Department of Health, Albany, NY 12208-3425 and <sup>2</sup>Department of Computer Science, Rensselaer Polytechnic Institute, Troy, NY 12180-3590, USA</aff>
      <author-notes>
        <fn>
          <p>Associate Editor: Thomas Lengauer</p>
        </fn>
      </author-notes>
      <pub-date pub-type="ppub">
        <day>15</day>
        <month>8</month>
        <year>2008</year>
      </pub-date>
      <pub-date pub-type="epub">
        <day>16</day>
        <month>6</month>
        <year>2008</year>
      </pub-date>
      <volume>24</volume>
      <issue>16</issue>
      <fpage>1772</fpage>
      <lpage>1778</lpage>
      <history>
        <date date-type="received">
          <day>23</day>
          <month>4</month>
          <year>2008</year>
        </date>
        <date date-type="rev-recd">
          <day>5</day>
          <month>6</month>
          <year>2008</year>
        </date>
        <date date-type="accepted">
          <day>10</day>
          <month>6</month>
          <year>2008</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>© 2008 The Author(s)</copyright-statement>
        <copyright-year>2008</copyright-year>
        <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">
          <p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/2.0/uk/) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        </license>
      </permissions>
      <abstract>
        <p><bold>Motivation:</bold> A backtrace through a dynamic programming algorithm's intermediate results in search of an optimal path, or to sample paths according to an implied probability distribution, or as the second stage of a forward–backward algorithm, is a task of fundamental importance in computational biology. When there is insufficient space to store all intermediate results in high-speed memory (e.g. cache) existing approaches store selected stages of the computation, and recompute missing values from these checkpoints on an as-needed basis.</p>
        <p><bold>Results:</bold> Here we present an optimal checkpointing strategy, and demonstrate its utility with pairwise local sequence alignment of sequences of length 10 000.</p>
        <p><bold>Availability:</bold> Sample C++-code for optimal backtrace is available in the <ext-link xmlns:xlink="http://www.w3.org/1999/xlink" ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/btn308/DC1">Supplementary Materials</ext-link>.</p>
        <p>
          <bold>Contact:</bold>
          <email>leen@cs.rpi.edu</email>
        </p>
        <p><bold>Supplementary information:</bold><ext-link xmlns:xlink="http://www.w3.org/1999/xlink" ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/btn308/DC1">Supplementary data</ext-link> is available at <italic>Bioinformatics</italic> online.</p>
      </abstract>
    </article-meta>
  </front>
  <body>
    <sec sec-type="intro" id="SEC1">
      <title>1 INTRODUCTION</title>
      <p>Dynamic programming algorithms are often used to find an optimal solution by backtracking through intermediate values of the computation. Typical examples are that of chain matrix multiplication, string algorithms such as longest common subsequence, the Viterbi (<xref ref-type="bibr" rid="B10">1967</xref>) algorithm for hidden Markov models, and sequence alignment algorithms such as those of Needleman and Wunsch (<xref ref-type="bibr" rid="B8">1970</xref>) and Smith and Waterman (<xref ref-type="bibr" rid="B9">1981</xref>). Dynamic programming algorithm backtraces are also used for random sampling, where the score for each possible backtrace path is deemed to be (proportional to) the probability of the path, and it is desired to choose a path according to that probability distribution. A typical example is the algorithm of Ding and Lawrence (<xref ref-type="bibr" rid="B2">1999</xref>) for the sampling of RNA secondary structure. A third use for dynamic programming backtraces is as the second step of a forward–backward algorithm, such as that of Baum–Welch (Baum <italic>et al.</italic> (<xref ref-type="bibr" rid="B1">1970</xref>) for finding the parameters of a hidden Markov model. Sometimes a trade-off with run time allows a problem to be solved without a backtrace through stored results, e.g. sequence alignment (Durbin <italic>et al.</italic>, <xref ref-type="bibr" rid="B3">2006</xref> Section 2.6; Myers and Miller, <xref ref-type="bibr" rid="B7">1998</xref>; Waterman, <xref ref-type="bibr" rid="B11">1995</xref>, page 211) and Baum–Welch (Miklós and Meyer, <xref ref-type="bibr" rid="B5">2005</xref>), but this is not always the case.</p>
      <p>When there is not enough space to store all intermediate results in high-speed memory, checkpointing strategies are employed, whereby selected stages of the computation are stored, and missing information is recomputed from these checkpoints on an as-needed basis. A stage of the computation, also known as a frontier, is a set of intermediate values that are sufficient for making subsequent computations. For instance, in a 2D dynamic programming algorithm that computes a small number of values for each (<italic>i,j</italic>) in a grid from the neighboring ‘earlier’ values associated with (<italic>i</italic>−1,<italic>j</italic>), (<italic>i,j</italic>−1) and (<italic>i</italic>−1,<italic>j</italic>−1), we could define a stage as a row of the computation grid. In this case, stage <italic>k</italic> would be the values associated with the cells {(<italic>k,j</italic>) : <italic>j</italic>=<italic>j</italic><sub>min</sub> … <italic>j</italic><sub>max</sub>}, and the stage <italic>k</italic> values would be sufficient for computing values for cell (<italic>i,j</italic>) for any <italic>i</italic>&gt;<italic>k</italic>. Similarly one could use columns to define stages. In many cases it makes sense to have overlapping stages; in the above example stage <italic>k</italic> might be the <italic>k</italic>-th diagonal frontier, i.e. the computation values associated with the cells {(<italic>i,j</italic>) : <italic>i</italic>+<italic>j</italic>∈{<italic>k</italic>−1,<italic>k</italic>}}.</p>
      <p>Herein we will describe an optimal checkpointing strategy that provably minimizes the number of stage re-computations necessary in performing a backtrace with limited high-speed memory. The algorithm is simple and efficient. Note that, because this limited-memory approach can be used to allow significant increases in locality of reference, it can provide more efficient computations even when the amount of high-speed memory might otherwise be considered sufficient.</p>
      <p>We build upon a previous approach that is fairly memory-efficient, which is described in <italic>Bioinformatics</italic> (Grice <italic>et al.</italic>, <xref ref-type="bibr" rid="B4">1997</xref>; Wheeler and Hughey, <xref ref-type="bibr" rid="B12">2000</xref>). With memory enough to store <italic>M</italic> stages, their ‘2-level’ algorithm uses the memory to compute the first <italic>M</italic> stages, but then retains only the <italic>M</italic>-th stage as a checkpoint, discarding the previous ones. Using the remaining <italic>M</italic>−1 memory locations, the algorithm computes stages <italic>M</italic>+1, …, 2<italic>M</italic>−1, and then uses the (2<italic>M</italic>−1)th stage as the second checkpoint. It continues this process, using the (<italic>M</italic>+(<italic>M</italic>−1)+(<italic>M</italic>−2))th stage as its third checkpoint, and so forth, up to and including <italic>M</italic>+(<italic>M</italic>−1)+···+1=<italic>M</italic>(<italic>M</italic>+1)/2 as its <italic>M</italic>-th checkpoint. Thus, if <italic>N</italic>=<italic>M</italic>(<italic>M</italic>+1)/2 stages are needed in the backtrace, they can be achieved with <inline-formula><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308i1"/></inline-formula> memory locations; in the backtrace, each missing stage is computed using the space freed by discarding the checkpoints that are no longer needed.</p>
      <p>Because the algorithm needs to compute each stage at most twice, once in the forward pass to create the checkpoints and once during the backtrace, the overall number of stage computations of the memory-reduced algorithm is at most double what it would have been.</p>
      <p>Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) also generalize their 2-level algorithm to an ‘<italic>L</italic>-level’ algorithm, where <italic>L</italic> is any positive integer. With <italic>M</italic> memory locations, the <italic>L</italic>-level algorithm can compute
<disp-formula id="M1"><label>(1)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m1"/></disp-formula>
stages, where this formula works for any integers <italic>L</italic> and <italic>M</italic> so long as the binomial coefficient <inline-formula><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308i2"/></inline-formula> is defined to be <italic>n</italic>!/<italic>d</italic>!(<italic>n</italic>−<italic>d</italic>)! when <italic>d</italic>≥0 and <italic>n</italic>−<italic>d</italic>≥0, and zero otherwise. The asymptotic limit is as <italic>M</italic>→∞ for fixed <italic>L</italic>. For the <italic>M, L</italic>≥1 algorithm, the <italic>k</italic>-th stage to be checkpointed is
<disp-formula id="M2"><label>(2)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m2"/></disp-formula>
That is, the first stage to be a checkpoint is the last stage that would be a checkpoint under the (<italic>L</italic>−1)-level algorithm. Generally, the <italic>k</italic>-th stage to be checkpointed is beyond the (<italic>k</italic>−1)th checkpoint by an amount that would be the last checkpoint for an (<italic>L</italic>−1)-level algorithm that uses the remaining <italic>M</italic>-(<italic>k</italic>−1) memory locations. Equation (<xref ref-type="disp-formula" rid="M2">2</xref>) solves to
<disp-formula id="M3"><label>(3)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m3"/></disp-formula></p>
      <p>The number of stage computations for the <italic>L</italic>-level algorithm to compute <italic>N</italic><sub>WH</sub>(<italic>M,L</italic>) stages using <italic>M</italic> memory locations is given by the recursion
<disp-formula id="M4"><label>(4)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m4"/></disp-formula>
because the <italic>L</italic>-level algorithm first computes all <italic>N</italic><sub>WH</sub>(<italic>M,L</italic>) stages, to get the <italic>L</italic>-level checkpoints; it then provides access to the stages in reverse order by working with the <italic>L</italic>-level checkpoints in reverse order; the <italic>L</italic>-level algorithm uses the (<italic>L</italic>−1)-level algorithm to generate the missing intervening stages. However, 1 is subtracted, because the last computation of each (<italic>L</italic>−1)-level algorithm invocation produces an <italic>L</italic>-level checkpoint that we already had available. Thus, this last computation for each (<italic>L</italic>−1)-level algorithm invocation is not performed. Equation (<xref ref-type="disp-formula" rid="M4">4</xref>) solves to
<disp-formula id="M5"><label>(5)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m5"/></disp-formula>
where this formula works for any integers <italic>L</italic> and <italic>M</italic> so long as the trinomial coefficient <inline-formula><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308i3"/></inline-formula> is defined to be (<italic>a</italic>+<italic>b</italic>+<italic>c</italic>)!/<italic>a</italic>!<italic>b</italic>!<italic>c</italic>!. when <italic>a, b, c</italic> ≥ 0, and zero otherwise. Thus we have a multiplier for the number of stage computations of approximately <italic>L</italic> for <inline-formula><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308i4"/></inline-formula> memory locations. Computed values of <italic>N</italic><sub>WH</sub>(<italic>M,L</italic>) and <italic>T</italic><sub>WH</sub>(<italic>M,L</italic>) for small <italic>M</italic> and <italic>L</italic> are given in <xref ref-type="table" rid="T1">Table 1</xref> and plotted in <xref ref-type="fig" rid="F1">Figure 1</xref>.</p>
      <table-wrap id="T1">
        <label>Table 1.</label>
        <caption>
          <p>The number of stages and run time for both the algorithm of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) and the optimal checkpointing algorithm</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead align="left">
            <tr>
              <th>Alg. L</th>
              <th colspan="7" align="center"><italic>T</italic><sub>WH</sub>(<italic>M,L</italic>)/<italic>N</italic><sub>WH</sub>(<italic>M,L</italic>)<hr/></th>
              <th colspan="7" align="center"><italic>T</italic><sub>opt</sub>(<italic>M,L</italic>)/<italic>N</italic><sub>opt</sub>(<italic>M,L</italic>)<hr/></th>
            </tr>
            <tr>
              <th/>
              <th>1</th>
              <th>2</th>
              <th>3</th>
              <th>4</th>
              <th>5</th>
              <th>6</th>
              <th>7</th>
              <th>1</th>
              <th>2</th>
              <th>3</th>
              <th>4</th>
              <th>5</th>
              <th>6</th>
              <th>7</th>
            </tr>
          </thead>
          <tbody align="left">
            <tr>
              <td><italic>M</italic>=1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
              <td>1/1</td>
            </tr>
            <tr>
              <td>2</td>
              <td>2/2</td>
              <td>4/3</td>
              <td>7/4</td>
              <td>11/5</td>
              <td>16/6</td>
              <td>22/7</td>
              <td>29/8</td>
              <td>3/2</td>
              <td>6/4</td>
              <td>12/6</td>
              <td>20/8</td>
              <td>30/10</td>
              <td>42/12</td>
              <td>56/14</td>
            </tr>
            <tr>
              <td>3</td>
              <td>3/3</td>
              <td>9/6</td>
              <td>21/10</td>
              <td>41/15</td>
              <td>71/21</td>
              <td>113/28</td>
              <td>169/36</td>
              <td>3/3</td>
              <td>13/8</td>
              <td>34/15</td>
              <td>70/24</td>
              <td>125/35</td>
              <td>203/48</td>
              <td>308/63</td>
            </tr>
            <tr>
              <td>4</td>
              <td>4/4</td>
              <td>16/10</td>
              <td>46/20</td>
              <td>106/35</td>
              <td>211/56</td>
              <td>379/84</td>
              <td>631/120</td>
              <td>4/4</td>
              <td>22/13</td>
              <td>70/29</td>
              <td>170/54</td>
              <td>350/90</td>
              <td>644/139</td>
              <td>1092/203</td>
            </tr>
            <tr>
              <td>5</td>
              <td>5/5</td>
              <td>25/15</td>
              <td>85/35</td>
              <td>225/70</td>
              <td>505/126</td>
              <td>1009/210</td>
              <td>1849/330</td>
              <td>5/5</td>
              <td>33/19</td>
              <td>123/49</td>
              <td>343/104</td>
              <td>798/195</td>
              <td>1638/335</td>
              <td>3066/539</td>
            </tr>
            <tr>
              <td>6</td>
              <td>6/6</td>
              <td>36/21</td>
              <td>141/56</td>
              <td>421/126</td>
              <td>1051/252</td>
              <td>2311/462</td>
              <td>4621/792</td>
              <td>6/6</td>
              <td>46/26</td>
              <td>196/76</td>
              <td>616/181</td>
              <td>1596/377</td>
              <td>3612/713</td>
              <td>7392/1253</td>
            </tr>
            <tr>
              <td>7</td>
              <td>7/7</td>
              <td>49/28</td>
              <td>217/84</td>
              <td>721/210</td>
              <td>1981/462
</td>
              <td>4753/924</td>
              <td>10 297/1716</td>
              <td>7/7</td>
              <td>61/34</td>
              <td>292/111</td>
              <td>1020/293
</td>
              <td>2910/671</td>
              <td>7194/1385</td>
              <td>15 972/2639</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn>
            <p>For the <italic>L</italic>-level backtracking algorithm of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) with memory suitable for storage of <italic>M</italic> stages, the left side of this table shows both <italic>N</italic><sub>WH</sub>(<italic>M,L</italic>), the number of stages that can be produced in reverse order, and <italic>T</italic><sub>WH</sub>(<italic>M,L</italic>), the number of stage computations required for that backtrace. [See Equations(<xref ref-type="disp-formula" rid="M1">1</xref>) and(<xref ref-type="disp-formula" rid="M5">5</xref>).] For instance, to perform a backtrace on <italic>N</italic>=36 stages with <italic>M</italic>=3 memory locations requires the (<italic>L</italic>=7)-level algorithm and requires <italic>T</italic>=169 stage computations. It is not straightforward to predict the number of stage computations for other values of <italic>N</italic> (<xref ref-type="fig" rid="F1">Fig. 1</xref>).</p>
          </fn>
          <fn>
            <p>For the optimal checkpointing algorithm presented here, the right side of this table shows both <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>), a number of stages that can be produced in reverse order, and <italic>T</italic>(<italic>M,N</italic><sub>opt</sub>(<italic>M,L</italic>)), the number of stage computations required for that backtrace. [See Equations(<xref ref-type="disp-formula" rid="M7">7</xref>) and(<xref ref-type="disp-formula" rid="M11">11</xref>).] When the number of stages is between <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) and <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>+1), the optimal number of stage computations <italic>T</italic><sub>opt</sub>(<italic>M,N</italic>) is computed via linear interpolation. For instance, to do the backtrace on <italic>N</italic>=36 stages with <italic>M</italic>=3 memory locations, we observe that <italic>N</italic> falls between <italic>N</italic><sub>opt</sub>(<italic>M</italic>=3,<italic>L</italic>=5)=35 and <italic>N</italic><sub>opt</sub>(<italic>M</italic>=3,<italic>L</italic>=6)=48. Thus, the algorithm requires <italic>T</italic>(<italic>M</italic>=3,<italic>N</italic>=36)=<italic>T</italic>(<italic>M</italic>=3,<italic>N</italic>=35)+6(36−35)=131 stage computations. Thus, in this case, the number of stage computations for the <italic>L</italic>-level algorithm of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) is 29% higher.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <fig id="F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Low memory comparison of algorithms. This figure exhibits the effect on the run time at low memory levels. Clockwise from the top, the curves come in 12 pairs, one each for <italic>M</italic>=2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15 and 20 memory locations. Within each pair, the curve for the <italic>L</italic>-level algorithm of (Wheeler and Hughey, <xref ref-type="bibr" rid="B12">2000</xref>) is first; as <italic>M</italic> increases these curves become increasingly ‘fractal’, with jumps in the run time at several scales. The curve for the optimal checkpointing algorithm is second in each pair; these curves are piecewise linear.</p>
        </caption>
        <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308f1"/>
      </fig>
      <p>The main drawback to the <italic>L</italic>-level algorithm is that it can perform badly for a value of <italic>N</italic> that falls between <italic>N</italic><sub>WH</sub>(<italic>M,L</italic>−1) and <italic>N</italic><sub>WH</sub>(<italic>M,L</italic>), for some <italic>L</italic>. Wheeler and Hughey, (<xref ref-type="bibr" rid="B12">2000</xref>) propose an ‘(<italic>L,L</italic>−1)-level’ algorithm that performs better for these intermediate values of <italic>N</italic>, but it is not optimal. Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) also discuss (<italic>L, L</italic>−1, …)-level algorithms and an optimal checkpointing algorithm, but do not provide a quick computation for choosing optimal checkpoints, nor do they give formulae to compute the number of stage computations for general values of <italic>M</italic> and <italic>N</italic>.</p>
    </sec>
    <sec sec-type="methods" id="SEC2">
      <title>2 METHODS</title>
      <p>The choice of the stages to checkpoint can be framed as an optimization problem. We write <italic>T</italic>(<italic>M,N</italic>) for the number of stage computations that are needed by the optimal checkpointing algorithm for a backtrace through <italic>N</italic> stages, using room for <italic>M</italic> stages. When <italic>N</italic>≤<italic>M</italic>, there is ample memory, and <italic>T</italic>(<italic>M,N</italic>)=<italic>N</italic>. At the other extreme, if <italic>M</italic>=1 there is room to compute only one stage, and <italic>N</italic>&gt;1 stages cannot be computed even with an infinite amount of time available. [Following the lead of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) we bar in-place calculations.]</p>
      <p>If <italic>N</italic>&gt;<italic>M</italic>&gt;1, and if we choose <italic>C</italic> as the first stage to checkpoint, then we begin by computing the first <italic>C</italic> stages, 1, …, <italic>C</italic>, by alternating the use of two memory locations. We store stage <italic>C</italic>, discarding the previous ones. Then, using the remaining <italic>M</italic>−1 memory locations, we recursively perform an optimal backtrace on the final <italic>N</italic>−<italic>C</italic> stages, <italic>C</italic>+1, …, <italic>N</italic>. Next, we present the retained stage <italic>C</italic> to the user. Finally, we discard stage <italic>C</italic> and recursively perform an optimal backtrace on the initial <italic>C</italic>−1 stages, using the full <italic>M</italic> memory locations. Thus, with an optimal choice for <italic>C</italic>, we have the recursion for <italic>T</italic>(<italic>M,N</italic>):
<disp-formula id="M6"><label>(6)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m6"/></disp-formula></p>
      <p>Note that Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) give a different recursion for optimal checkpointing. Translated into our notation, their recursion is <italic>T</italic>(<italic>M,N</italic>)=min<sub><italic>C</italic></sub>{<italic>C</italic>+<italic>T</italic>(<italic>M</italic>−1,<italic>N</italic>−<italic>C</italic>)+<italic>T</italic>(<italic>M,C</italic>)−1}. This error may have impeded their further progress.</p>
      <p>A straightforward computation of this recursion would require 𝒪(<italic>M</italic><italic>N</italic><sup>2</sup>) time (Wheeler and Hughey, <xref ref-type="bibr" rid="B12">2000</xref>). However, in the following we will show a mathematical solution to the recursion that permits the calculation of all the needed checkpoints in 𝒪(<italic>N</italic>) time.</p>
      <p>As with the analysis of the <italic>L</italic>-level algorithm of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>), we find it easier to initially restrict our attention to special values of <italic>N</italic>. The main contribution of this work is our subsequent generalization to arbitrary values of <italic>N</italic>.</p>
      <sec id="SEC2.1">
        <title>2.1 Special values for the number of stages</title>
        <p>With storage for <italic>M</italic>≥1 stages, and for any integer <italic>L</italic>≥1, we will define a special number of stages <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>), and we will calculate <italic>T</italic><sub>opt</sub>(<italic>M,L</italic>), the number of stage computations required for a backtrace through <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) stages using <italic>M</italic> memory locations. Let
<disp-formula id="M7"><label>(7)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m7"/></disp-formula>
For <italic>M,L</italic>&gt;1, with <italic>N</italic>=<italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) stages, we set
<disp-formula id="M8"><label>(8)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m8"/></disp-formula>
the unique optimum checkpoint stage for the problem with <italic>M</italic> memory locations and <italic>N</italic>=<italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) stages (see Appendix for proofs). Plugging <italic>C</italic>(<italic>M,N</italic>)=<italic>N</italic><sub>opt</sub>(<italic>M,L</italic>−1)+1 and <italic>N</italic>−C(<italic>M,N</italic>)=<italic>N</italic><sub>opt</sub>(<italic>M</italic>−1,<italic>L</italic>) into Equation (<xref ref-type="disp-formula" rid="M6">6</xref>), we obtain
<disp-formula id="M9"><label>(9)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m9"/></disp-formula>
This solves to
<disp-formula id="M10"><label>(10)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m10"/></disp-formula>
<disp-formula id="M11"><label>(11)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m11"/></disp-formula>
where Equation (<xref ref-type="disp-formula" rid="M11">11</xref>) is defined for <italic>M</italic>≥2 only. Computed values of <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) and <italic>T</italic><sub>opt</sub>(<italic>M,L</italic>) for small <italic>M</italic> and <italic>L</italic> are given in <xref ref-type="table" rid="T1">Table 1</xref> and plotted in <xref ref-type="fig" rid="F1">Figure 1</xref>.</p>
        <p>As with the <italic>L</italic>-level algorithm of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>), with the optimal checkpointing algorithm, we have a multiplier for the number of stage computations of approximately <italic>L</italic> for <inline-formula><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308i5"/></inline-formula> memory locations. However, we shall now see that, with the optimal checkpointing algorithm, we easily achieve this multiplier for the number of stage computations even when the number of stages <italic>N</italic> is arbitrary.</p>
        <fig id="F2">
          <label>Fig. 2.</label>
          <caption>
            <p>The optimal checkpointing algorithm in pseudo-C++, for a backtrace through <italic>N</italic> stages using memory sufficient for <italic>M</italic> stages. Using Equation (<xref ref-type="disp-formula" rid="M7">7</xref>), find the level <italic>L</italic>=max{<italic>L</italic> : <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>)≤<italic>N</italic>}. For the convention that the memory locations are labeled 0, …, <italic>M</italic>−1 and the stages are labeled 0, …, <italic>N</italic>−1, invoke backtrace(−1, <italic>M</italic>, −1, <italic>N, L, N</italic><sub>opt</sub>(<italic>M,L</italic>), <italic>advance, available, p</italic>); where <italic>advance</italic> is a pointer to a callback function that computes stage <italic>N</italic><sub><italic>to</italic></sub>, to be stored in memory location <italic>M</italic><sub>to</sub>, from the immediately preceding stage, which is stored in memory location <italic>M</italic><sub>from</sub> unless <italic>N</italic><sub>to</sub> is the first stage; where <italic>available</italic> is a pointer to a callback function invoked during backtrace so that the user can make use of stage <italic>N</italic>, stored in memory location <italic>M</italic>; and where <italic>p</italic> is a user-supplied pointer to applicable stage-independent information. BIGINT should be an integer type able to handle integers a little larger than <italic>N M</italic><sup>2</sup>. Note that, although the <italic>backtrace</italic> routine directs the callback routines on the use of the memory locations, the actual allocation and access of the memory is not handled by the <italic>backtrace</italic> routine. Further, note that if the generality is not required, the pointer parameters, <italic>advance, available</italic> and <italic>p</italic>, can be eliminated, and their use in the body of the function can be replaced by ‘hard-wired’ calls to appropriate functions. See the Supplementary Materials for C++source code.</p>
          </caption>
          <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308f2"/>
        </fig>
      </sec>
      <sec id="SEC2.2">
        <title>2.2 General values for the number of stages</title>
        <p>When <italic>N</italic> falls between two optimal values, <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) and <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>+1), we can compute the number of stage computations <italic>T</italic>(<italic>M,N</italic>) by linear interpolation between <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) and <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>+1) (see Appendix for proofs). Noting that
<disp-formula id="M12"><label>(12)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m12"/></disp-formula>
we derive
<disp-formula id="M13"><label>(13)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m13"/></disp-formula>
for <italic>N</italic>≥<italic>M</italic>&gt;1.</p>
        <p>Furthermore, for <italic>N</italic> between <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) and <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>+1), it is optimal to choose the initial checkpoint <italic>C</italic>(<italic>M,N</italic>) so that <italic>C</italic>(<italic>M,N</italic>)−1 and <italic>N</italic>−<italic>C</italic>(<italic>M,N</italic>) fall between the values that they would have had to equal, if <italic>N</italic> had equaled <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) or <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>+1). That is, we must choose <italic>C</italic>(<italic>M,N</italic>) so as to simultaneously satisfy
<disp-formula id="M14"><label>(14)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m14"/></disp-formula>
and
<disp-formula id="M15"><label>(15)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m15"/></disp-formula>
In practice, we choose the largest legal value,
<disp-formula id="M16"><label>(16)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m16"/></disp-formula></p>
        <p>The optimal checkpointing algorithm is presented in <xref ref-type="fig" rid="F2">Figure 2</xref>. Note that we include not just <italic>M</italic>, and <italic>N</italic>, but also a level <italic>L</italic> and a special stage <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) in the parameter list for the recursive subroutine, because the availability of values for <italic>L</italic> and <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) greatly speeds the calculations of <italic>N</italic><sub>opt</sub>(<italic>M</italic>−1,<italic>L</italic>) and <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>−1), which are needed in the calculations of optimal checkpoints:
<disp-formula id="M17"><label>(17)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m17"/></disp-formula>
<disp-formula id="M18"><label>(18)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m18"/></disp-formula></p>
        <p>It is imperative that the required calculations be impervious to integer overflows. We initially prevented overflow in integer calculations, such as <italic>abc</italic>/<italic>de</italic> for Equations (<xref ref-type="disp-formula" rid="M17">17</xref>) and (<xref ref-type="disp-formula" rid="M18">18</xref>), by canceling all common factors between each variable in the numerator and each variable in the denominator. This approach requires 3 × 2=6 invocations of Euclid's algorithm for finding a greatest common divisor. Such a procedure leaves the value of each denominator variable at 1 and, when <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>)+1 can be represented as an integer, the numerator variable values are sufficiently small enough to permit all the needed computations—so long as extra care is taken when verifying that the initial value of <italic>N</italic> is less than <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>+1).</p>
        <p>To handle computations where the number of stages exceeds the largest unsigned integer, often 2<sup>32</sup>−1≈4 × 10<sup>9</sup>, we modified our C++software implementation to use a C++class that manipulates integers of arbitrary size.</p>
      </sec>
    </sec>
    <sec id="SEC3">
      <title>3 SOFTWARE</title>
      <p>Sample C++-code for optimal backtrace is available in the <ext-link xmlns:xlink="http://www.w3.org/1999/xlink" ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/btn308/DC1">Supplementary Materials</ext-link>.</p>
    </sec>
    <sec sec-type="results" id="SEC4">
      <title>4 RESULTS</title>
      <p>We applied the algorithm to pairwise local alignments (Smith and Waterman, <xref ref-type="bibr" rid="B9">1981</xref>) of sequences of up to 3000 nucleotides of human DNA with sequences of up to 2864 nucleotides of rodent DNA. For the largest of the alignments, to keep within a 125 MB limit for total memory use, we restricted ourselves to <italic>M</italic>=486 stages of storage for the <italic>N</italic>=2864 stages. For these choices, <italic>L</italic>=1, <italic>N</italic><sub>opt</sub>(<italic>M</italic>=486, <italic>L</italic>=1)=486, and <italic>T</italic>(<italic>M</italic>=486, <italic>N</italic>=2864)=5242. Thus, the multiplier for the number of stage computations is <italic>T</italic>/<italic>N</italic>=5242/2864≈1.83 for memory use <italic>M</italic>/<italic>N</italic>=486/2864≈17%. The algorithm ran in 70 s, but would have run much more slowly if it had tried to use memory for all 2864 stages, because the resulting memory swapping would have been onerous. In contrast, the 2-level algorithm of (Wheeler and Hughey, <xref ref-type="bibr" rid="B12">2000</xref>) computes checkpoints for stages 486, 971, 1455, 1938 and 2420, and requires two computations for all other stages with index under 2420. Thus its total number of stage computations is 2864+(2420−5)=5279, only slightly worse than 5242.</p>
      <p>The same calculation performed on a pair of sequences, each 10 000 nucleotides long, takes 12 min to run in 125 MB of memory, a memory size sufficient to store only 138 stages instead of the full 10 000 stages. For a problem of this size, <italic>L</italic>=2, <italic>N</italic><sub>opt</sub>(<italic>M</italic>=138, <italic>L</italic>=2)=9728, and <italic>T</italic>(<italic>M</italic>=138, <italic>N</italic>=10 000)=20 134. Thus, the multiplier for the number of stage computations is <italic>T</italic>/<italic>N</italic>=20 134 / 10 000≈2.01 for memory use<italic>M</italic>/<italic>N</italic>=138/10 000≈1.4%. In contrast, the 3-level algorithm ofWheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) is at a particular disadvantage in that it computes its only 3-level checkpoint at stage 9591, with subsequent 2-level checkpoints at 9728, 9864, and 9999. The algorithm requires 29 448 stage computations, significantly worse than 20 134. With 1 GB of memory, sufficient for storing 1104 stages for the pairwise alignment of sequences of length 10 000 nucleotides, the optimal checkpointing algorithm requires 18 896 stage computations, whereas the 2-level algorithm of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>) requires 19 891 stage computations, almost 1000 more.</p>
      <p>On similar datasets, using a probabilistic model that defines a probability distribution on the set of possible alignments, we used the optimal backtrace algorithm to compute a centroid (Ding and Lawrence, <xref ref-type="bibr" rid="B2">1999</xref>), also known as a posterior decoding (Miyazawa, <xref ref-type="bibr" rid="B6">1995</xref>). This task requires a dynamic programming calculation during the backtrace that is comparable to the calculation performed during the forward pass. With sufficient memory, the total computation would require 2<italic>N</italic> stage computations, thus the multiplier for the number of stage computations with limited memory is
<disp-formula id="M19"><label>(19)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m19"/></disp-formula>
this value is better than <italic>L</italic>, the multiplier of the number of stage computations for the cheaper backtrace tasks.</p>
      <p>We also can draw independent samples from the probability distribution on the set of possible alignments. Here, the run time is as slow as the centroid calculation only when the number of samples to be drawn is of the order of the smaller of the two sequence lengths.</p>
    </sec>
    <sec sec-type="discussion" id="SEC5">
      <title>5 DISCUSSION</title>
      <p>We have provided an algorithm for optimal backtrace through a dynamic programming algorithm when memory is limited. The algorithm improves upon previous work via the simplicity and speed of the calculation for the index of the optimal checkpoint, and via achievement of optimal performance for a problem of arbitrary size.</p>
      <p>A few variations are worthy of consideration. Generally, for backtrace computations, whether or not they are achieved with the optimal checkpointing algorithm described here, the first stage is computed from initial or boundary conditions, and each subsequent stage is computed from the immediately preceding stage. Thus, at least conceptually, the first stage requires special treatment. If this distinction makes implementation of the <italic>advance</italic> callback routine difficult, it may be prudent to compute and permanently store the first stage in the first memory location, and to run the optimal checkpointing algorithm so as to provide an optimally computed backtrace through the remaining <italic>N</italic>−1 stages using <italic>M</italic>−1 memory locations. The number of stage computations for this approach is 1+<italic>T</italic>(<italic>M</italic>−1,<italic>N</italic>−1).</p>
      <p>As already described for both optimal checkpointing and the <italic>L</italic>-level algorithm of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>), in the limit as the number of memory locations <italic>M</italic> goes to infinity with a fixed multiplier <italic>L</italic> for the number of stage computations, we can backtrace through <italic>N</italic> ∼ <italic>M</italic><sup><italic>L</italic></sup> / <italic>L</italic>! stages with <italic>T</italic> ∼ <italic>M</italic><sup><italic>L</italic></sup> / (<italic>L</italic>−1)! stage computations. However, for the case when memory is severely limited, it is instructive to look at the asymptotics for a fixed value of <italic>M</italic>, with <italic>L</italic> tending to infinity. For this situation we have
<disp-formula id="M20"><label>(20)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m20"/></disp-formula>
<disp-formula id="M21"><label>(21)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m21"/></disp-formula>
<disp-formula id="M22"><label>(22)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m22"/></disp-formula>
<disp-formula id="M23"><label>(23)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m23"/></disp-formula>
Thus, in these low-memory situations, the optimal algorithm is asymptotically faster than the <italic>L</italic>-level algorithm of Wheeler and Hughey (<xref ref-type="bibr" rid="B12">2000</xref>), even when the latter is applied to its optimal problem sizes <italic>N</italic><sub>WH</sub>(<italic>M,L</italic>). The speed multiplier is <inline-formula><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308i6"/></inline-formula>, which is approximately 1+(0.693}/(<italic>M</italic>−1.347)) for moderate values of <italic>M</italic>. See <xref ref-type="table" rid="T1">Table 1</xref> and <xref ref-type="fig" rid="F1">Figure 1</xref>.</p>
    </sec>
    <sec sec-type="conclusions" id="SEC6">
      <title>6 CONCLUSION</title>
      <p>When high-speed memory is limited, dynamic programming algorithm backtraces make use of checkpoints for re-computing needed intermediate values. We have provided an easy-to-use algorithm for optimally selecting the checkpoints.</p>
    </sec>
  </body>
  <back>
    <ack>
      <title>ACKNOWLEDGEMENTS</title>
      <p>We thank the Computational Molecular Biology and Statistics Core Facility at the Wadsworth Center for the computing resources for the pairwise local sequence alignment calculations.We wish to acknowledge use of the Maple software package by Waterloo Maple, Inc., without which the calculations in this article would have been much more difficult.</p>
      <p><italic>Funding</italic>: This research was supported by the National Institutes of Health / National Human Genome Research Institute grant K25 HG003291.</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </ack>
    <app-group>
      <app>
        <title>APPENDIX: PROOF OF RUN TIME</title>
        <p>So that this section is self-contained, we will restate the relevant assumptions and definitions.</p>
        <p>We define the following functions and will prove their usefulness presently.
<disp-formula id="M24"><label>(24)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m24"/></disp-formula>
<disp-formula id="M25"><label>(25)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m25"/></disp-formula>
We take as given that the number of stage computations required satisfies:
<disp-formula id="M26"><label>(26)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m26"/></disp-formula>
where a choice of value for <italic>C</italic> that minimizes this last expression for a given <italic>N</italic> and <italic>M</italic> is called an optimal first checkpoint, <italic>C</italic>(<italic>M,N</italic>).</p>
        <statement>
          <title>T<sc>HEOREM</sc>.</title>
          <p>
            <italic>Let N be the number of stages to be made available in a backtrace using storage for M stages. For a choice of N and M, define</italic>
            <disp-formula id="M27">
              <label>(27)</label>
              <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m27"/>
            </disp-formula>
            <italic>We will show that</italic>
            <disp-formula id="M28">
              <label>(28)</label>
              <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m28"/>
            </disp-formula>
          </p>
          <p><italic>for N</italic> ≥ <italic>M</italic> ≥ 1, <italic>where the second term is deemed zero if N</italic>=<italic>N</italic><sub>opt</sub>(<italic>M,L</italic>), <italic>even when L</italic>=+∞. <italic>We will show that, when N</italic>&gt;<italic>M</italic>&gt;1, <italic>the value of an optimal first checkpoint C</italic>(<italic>M,N</italic>) <italic>satisfies</italic>
<disp-formula id="M29"><label>(29)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m29"/></disp-formula>
<italic>and</italic>
<disp-formula id="M30"><label>(30)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m30"/></disp-formula></p>
        </statement>
        <statement>
          <title>P<sc>ROOF</sc>.</title>
          <p><italic>The proof will be by induction on N and M. We have two base cases: first, a base case for a low value of N and, second, a base case for a low value of M</italic>.</p>
          <p>Base case, <italic>N</italic>=<italic>M</italic> ≥ 1</p>
          <p>We wish to show that Equation (<xref ref-type="disp-formula" rid="M28">A5</xref>) correctly matches Equation (<xref ref-type="disp-formula" rid="M26">A3</xref>) when <italic>N</italic>=<italic>M</italic> ≥ 1.</p>
          <p>We put <italic>L</italic>=1 into Equation (<xref ref-type="disp-formula" rid="M24">A1</xref>) for <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) and Equation (<xref ref-type="disp-formula" rid="M24">A1</xref>) for <italic>T</italic><sub>opt</sub>(<italic>M,L</italic>):
<disp-formula id="M31"><label>(31)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m31"/></disp-formula>
<disp-formula id="M32"><label>(32)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m32"/></disp-formula>
where the trinomial terms with <italic>L</italic>−2 vanish by our convention. Thus, for this base case, Equation (<xref ref-type="disp-formula" rid="M27">A4</xref>) indicates that <italic>L</italic>=1. It follows that Equation (<xref ref-type="disp-formula" rid="M28">A5</xref>) gives <italic>T</italic>(<italic>M,N</italic>)=<italic>M</italic>, which is in agreement with Equation (<xref ref-type="disp-formula" rid="M26">A3</xref>) because <italic>N</italic>=<italic>M</italic>.</p>
          <p>Base Case, <italic>N</italic>&gt;<italic>M</italic>=1</p>
          <p>We wish to show that Equation (<xref ref-type="disp-formula" rid="M28">A5</xref>) correctly matches Equation (<xref ref-type="disp-formula" rid="M26">A3</xref>) when <italic>N</italic>&gt;<italic>M</italic>=1.</p>
          <p>We put <italic>M</italic>=1 into Equation (<xref ref-type="disp-formula" rid="M24">A1</xref>) for <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) and Equation (<xref ref-type="disp-formula" rid="M25">A2</xref>) for <italic>T</italic><sub>opt</sub>(<italic>M,L</italic>):
<disp-formula id="M33"><label>(33)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m33"/></disp-formula>
<disp-formula id="M34"><label>(34)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m34"/></disp-formula>
Thus, for this base case, Equation (<xref ref-type="disp-formula" rid="M27">A4</xref>) indicates that <italic>L</italic>=+∞. Because <italic>N</italic> is strictly greater than <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>) (for any <italic>L</italic>) it follows that Equation (<xref ref-type="disp-formula" rid="M28">A5</xref>) gives <italic>T</italic>(<italic>M</italic>=1,<italic>N</italic>&gt;1)=+∞, in agreement with Equation (<xref ref-type="disp-formula" rid="M26">A3</xref>), as desired.</p>
        </statement>
        <p>General Case, <italic>N</italic>&gt;<italic>M</italic>&gt;1</p>
        <p>We assume that the theorem is proved true for <italic>N</italic>′ ≥ <italic>M</italic>′ ≥ 1, when <italic>N</italic>′≤<italic>N</italic> and <italic>M</italic>′≤<italic>M</italic> but (<italic>N</italic>′,<italic>M</italic>′) ≠ (<italic>N, M</italic>). We will show that checkpoint choices <italic>C</italic>′ and <italic>C</italic>″=<italic>C</italic>′+1 will give the same number of stage computations if both <italic>C</italic>′ and <italic>C</italic>″ satisfy the restrictions of Equations (<xref ref-type="disp-formula" rid="M29">A6</xref>) and (<xref ref-type="disp-formula" rid="M30">A7</xref>). We will show that if <italic>C</italic>″ is too high to satisfy these restrictions then use of <italic>C</italic>′ will lead to fewer stage computations; we will show that if <italic>C</italic>′ is too low to satisfy these restrictions then use of <italic>C</italic>″ will lead to fewer stage computations. Together these will demonstrate that the restrictions are optimal and that they can be satisfied simultaneously. We will then show that satisfaction of the restrictions implies Equation (<xref ref-type="disp-formula" rid="M28">A5</xref>).</p>
        <p>Let <italic>T</italic>′(<italic>M,N</italic>) and <italic>T</italic>″(<italic>M,N</italic>) be the number of stage computations required given that <italic>C</italic>′ or <italic>C</italic>″, respectively, is chosen as the first checkpoint, and optimal checkpoints are used in all remaining subproblems:
<disp-formula id="M35"><label>(35)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m35"/></disp-formula>
and
<disp-formula id="M36"><label>(36)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m36"/></disp-formula></p>
        <p>Set <italic>L</italic><sub>1</sub> to be the unique integer such that
<disp-formula id="M37"><label>(37)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m37"/></disp-formula>
and observe that
<disp-formula id="M38"><label>(38)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m38"/></disp-formula>
Set <italic>L</italic><sub>2</sub> to be the unique integer such that
<disp-formula id="M39"><label>(39)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m39"/></disp-formula>
and observe that
<disp-formula id="M40"><label>(40)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m40"/></disp-formula>
Using our induction hypothesis [Equation (<xref ref-type="disp-formula" rid="M28">A5</xref>)], we thus compute that
<disp-formula id="M41"><label>(41)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m41"/></disp-formula>
<disp-formula id="M42"><label>(42)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m42"/></disp-formula>
<disp-formula id="M43"><label>(43)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m43"/></disp-formula></p>
        <p>We observe that when both <italic>C</italic>′ and <italic>C</italic>″ satisfy the restrictions given as Equations (<xref ref-type="disp-formula" rid="M29">A6</xref>) and (<xref ref-type="disp-formula" rid="M30">A7</xref>) then <italic>L</italic><sub>1</sub>=<italic>L</italic><sub>2</sub> and the stages <italic>C</italic>′ and <italic>C</italic>″ make equally good choices as a checkpoint. When <italic>C</italic>″ is too large for the restrictions then <italic>L</italic><sub>1</sub>&gt;<italic>L</italic><sub>2</sub>, and when <italic>C</italic>′ is too small for the restrictions then <italic>L</italic><sub>1</sub>&lt;<italic>L</italic><sub>2</sub>. Thus, we have verified that the restrictions define an optimal first checkpoint.</p>
        <p>Finally, using the induction hypothesis, we compute <italic>T</italic>(<italic>M,N</italic>) to verify that it yields Equation (<xref ref-type="disp-formula" rid="M28">A5</xref>), using a value of <italic>C</italic> satisfying the restrictions of Equations (<xref ref-type="disp-formula" rid="M29">A6</xref>) and (<xref ref-type="disp-formula" rid="M30">A7</xref>).
<disp-formula id="M44"><label>(44)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m44"/></disp-formula>
<disp-formula id="M45"><label>(45)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m45"/></disp-formula>
<disp-formula id="M46"><label>(46)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m46"/></disp-formula>
<disp-formula id="M47"><label>(47)</label><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btn308m47"/></disp-formula>
as desired. For the last equality, we have used <italic>N</italic><sub>opt</sub>(<italic>M,L</italic>)=<italic>N</italic><sub>opt</sub>(<italic>M,L</italic>)+<italic>N</italic><sub>opt</sub>(<italic>M,L</italic>1)+1 and <italic>T</italic><sub>opt</sub>(<italic>M,L</italic>)=<italic>T</italic><sub>opt</sub>(<italic>M</italic>−1,<italic>L</italic>)+<italic>T</italic><sub>opt</sub>(<italic>M,L</italic>−1)+<italic>N</italic><sub>opt</sub>(<italic>M,L</italic>−1)+1, which are easily proved from Equations (<xref ref-type="disp-formula" rid="M24">A1</xref>) and (<xref ref-type="disp-formula" rid="M25">A2</xref>).</p>
      </app>
    </app-group>
    <ref-list>
      <title>REFERENCES</title>
      <ref id="B1">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Baum</surname>
              <given-names>LE</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>A maximization technique occurring in the statistical analysis of probabilistic functions of Markov chains</article-title>
          <source>Ann. Math. Statist</source>
          <year>1970</year>
          <volume>41</volume>
          <fpage>164</fpage>
          <lpage>171</lpage>
        </nlm-citation>
      </ref>
      <ref id="B2">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Ding</surname>
              <given-names>Y</given-names>
            </name>
            <name>
              <surname>Lawrence</surname>
              <given-names>CE</given-names>
            </name>
          </person-group>
          <article-title>ABayesian statistical algorithm for RNA secondary structure prediction</article-title>
          <source>Comput. Chem</source>
          <year>1999</year>
          <volume>23</volume>
          <fpage>387</fpage>
          <lpage>400</lpage>
        </nlm-citation>
      </ref>
      <ref id="B3">
        <nlm-citation citation-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Durbin</surname>
              <given-names>R</given-names>
            </name>
            <etal/>
          </person-group>
          <source>Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids.</source>
          <year>2006</year>
          <publisher-loc>Cambridge, UK</publisher-loc>
          <publisher-name>Cambridge University Press</publisher-name>
        </nlm-citation>
      </ref>
      <ref id="B4">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Grice</surname>
              <given-names>JA</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>Reduced space sequence alignment</article-title>
          <source>Comput. Appl. Biosci</source>
          <year>1997</year>
          <volume>13</volume>
          <fpage>45</fpage>
          <lpage>53</lpage>
        </nlm-citation>
      </ref>
      <ref id="B5">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Miklós</surname>
              <given-names>I</given-names>
            </name>
            <name>
              <surname>Meyer</surname>
              <given-names>IM</given-names>
            </name>
          </person-group>
          <article-title>A linear memory algorithm for Baum-Welch training</article-title>
          <source>BMC Bioinformatics</source>
          <year>2005</year>
          <volume>6</volume>
          <fpage>231</fpage>
        </nlm-citation>
      </ref>
      <ref id="B6">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Miyazawa</surname>
              <given-names>S</given-names>
            </name>
          </person-group>
          <article-title>A reliable sequence alignment method based on probabilities of residue correspondences</article-title>
          <source>Protein Eng</source>
          <year>1995</year>
          <volume>8</volume>
          <fpage>999</fpage>
          <lpage>1009</lpage>
        </nlm-citation>
      </ref>
      <ref id="B7">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Myers</surname>
              <given-names>EW</given-names>
            </name>
            <name>
              <surname>Miller</surname>
              <given-names>W</given-names>
            </name>
          </person-group>
          <article-title>Optimal alignments in linear space</article-title>
          <source>Comput. Appl. Biosci</source>
          <year>1998</year>
          <volume>4</volume>
          <fpage>11</fpage>
          <lpage>17</lpage>
        </nlm-citation>
      </ref>
      <ref id="B8">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Needleman</surname>
              <given-names>SB</given-names>
            </name>
          </person-group>
          <article-title>Ageneral method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
          <source>J. Mol. Biol</source>
          <year>1970</year>
          <volume>48</volume>
          <fpage>443</fpage>
          <lpage>453</lpage>
        </nlm-citation>
      </ref>
      <ref id="B9">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Smith</surname>
              <given-names>TF</given-names>
            </name>
            <name>
              <surname>Waterman</surname>
              <given-names>MS</given-names>
            </name>
          </person-group>
          <article-title>Comparison of biosequences</article-title>
          <source>Adv. Appl. Math</source>
          <year>1981</year>
          <volume>2</volume>
          <fpage>482</fpage>
          <lpage>489</lpage>
        </nlm-citation>
      </ref>
      <ref id="B10">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Viterbi</surname>
              <given-names>AJ</given-names>
            </name>
          </person-group>
          <article-title>Error bounds for convolutional codes and an asymptotically optimum decoding algorithm</article-title>
          <source>IEEE T. Inform. Theory</source>
          <year>1967</year>
          <volume>13</volume>
          <fpage>260</fpage>
          <lpage>269</lpage>
        </nlm-citation>
      </ref>
      <ref id="B11">
        <nlm-citation citation-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Waterman</surname>
              <given-names>MS</given-names>
            </name>
          </person-group>
          <source>Introduction to Computational Biology. Maps, Sequences and Genomes.</source>
          <year>1995</year>
          <publisher-loc>London, UK</publisher-loc>
          <publisher-name>Chapman &amp; Hall/CRC</publisher-name>
        </nlm-citation>
      </ref>
      <ref id="B12">
        <nlm-citation citation-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Wheeler</surname>
              <given-names>R</given-names>
            </name>
            <name>
              <surname>Hughey</surname>
              <given-names>R</given-names>
            </name>
          </person-group>
          <article-title>Optimizing reduced-space sequence analysis</article-title>
          <source>Bioinformatics</source>
          <year>2000</year>
          <volume>16</volume>
          <fpage>1082</fpage>
          <lpage>1090</lpage>
        </nlm-citation>
      </ref>
    </ref-list>
  </back>
</article>
